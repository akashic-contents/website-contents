"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Box2D = void 0;
const box2dweb = require("box2dweb");
/**
 * AkashicのエンティティをBox2DWebのb2Worldに追加し、演算結果をエンティティに反映するクラス。
 */
class Box2D {
    /**
     * `Box2D` のインスタンスを生成する。
     * @param param `b2World` の生成オプション
     */
    constructor(param) {
        /**
         * このクラスが保持する `EBody` のリスト。
         */
        this.bodies = [];
        this._createBodyCount = 0;
        // オブジェクト生成を減らすためのキャッシュ
        this._matrix = new g.PlainMatrix();
        if (param.gravity == null) {
            throw g.ExceptionFactory.createAssertionError("Missing parameter: gravity");
        }
        if (param.scale == null) {
            throw g.ExceptionFactory.createAssertionError("Missing parameter: scale");
        }
        const sleep = param.sleep != null ? !!param.sleep : true;
        const b2world = new box2dweb.Dynamics.b2World(new box2dweb.Common.Math.b2Vec2(param.gravity[0], param.gravity[1]), sleep);
        this.scale = param.scale;
        this.world = b2world;
    }
    /**
     * このクラスにボディを追加し、その `EBody` を返す。
     * すでに同エンティティが追加されている場合は何もせず `null` を返す。
     * エンティティのアンカーポイントが (0.5, 0.5) に指定される点に注意。
     * @param entity 対象のエンティティ
     * @param bodyDef 対象のb2BodyDef
     * @param fixtureDef 対象のb2FixtureDefまたは対象のb2FixtureDefの配列
     */
    createBody(entity, bodyDef, fixtureDef) {
        for (let i = 0; i < this.bodies.length; i++) {
            if (this.bodies[i].entity === entity) {
                return null;
            }
        }
        const fixtureDefs = Array.isArray(fixtureDef) ? fixtureDef : [fixtureDef];
        const b2Body = this.world.CreateBody(bodyDef);
        for (let i = 0; i < fixtureDefs.length; i++) {
            b2Body.CreateFixture(fixtureDefs[i]);
        }
        if (entity.anchorX !== 0.5 || entity.anchorY !== 0.5) {
            const m = this._matrix;
            const e = entity;
            m.update(e.width, e.height, e.scaleX, e.scaleY, e.angle, e.x, e.y, e.anchorX, e.anchorY);
            const { x, y } = m.multiplyPoint({ x: e.width / 2, y: e.height / 2 });
            e.x = x;
            e.y = y;
            e.anchorX = 0.5;
            e.anchorY = 0.5;
        }
        b2Body.SetPositionAndAngle(this.vec2(entity.x, entity.y), this.radian(entity.angle));
        b2Body.SetUserData(bodyDef.userData != null ? bodyDef.userData : entity.id);
        const body = {
            id: `${this._createBodyCount++}`,
            entity,
            b2Body
        };
        this.bodies.push(body);
        return body;
    }
    /**
     * このクラスに追加された `EBody` を削除する。
     * step() 中は削除できない。 (例えば接触判定のコールバック内など)
     * @param ebody 削除する `EBody`
     */
    removeBody(ebody) {
        const index = this.bodies.indexOf(ebody);
        if (index === -1) {
            return;
        }
        if (this.world.IsLocked()) {
            throw new Error("removeBody(): can't remove a body while the world is locked (step() is running). Please call after step()");
        }
        this.world.DestroyBody(ebody.b2Body);
        this.bodies.splice(index, 1);
    }
    /**
     * エンティティからこのクラスに追加されている `EBody` を返す。
     * @param entity エンティティ
     */
    getEBodyFromEntity(entity) {
        for (let i = 0; i < this.bodies.length; i++) {
            if (this.bodies[i].entity === entity) {
                return this.bodies[i];
            }
        }
        return null;
    }
    /**
     * `b2Body` からこのクラスに追加されている `EBody` を返す。
     * @param b2Body b2Body
     */
    getEBodyFromb2Body(b2Body) {
        for (let i = 0; i < this.bodies.length; i++) {
            if (this.bodies[i].b2Body === b2Body) {
                return this.bodies[i];
            }
        }
        return null;
    }
    /**
     * このクラスのインスタンスを破棄する。
     */
    destroy() {
        this.world = undefined;
        this.bodies = undefined;
    }
    /**
     * このクラスのインスタンスが破棄済みであるかを返す。
     */
    destroyed() {
        return this.world === undefined;
    }
    /**
     * 時間を経過させ、このクラスに追加されたエンティティの座標と角度を変更する。
     * このメソッドは暗黙的に `E#modified()` を呼び出している。
     * @param dt 経過させる時間単位
     * @param velocityIteration 速度演算のイテレーション回数 省略時は10
     * @param positionIteration 位置演算のイテレーション回数 省略時は10
     */
    step(dt, velocityIteration = 10, positionIteration = 10) {
        this.world.Step(dt, velocityIteration, positionIteration);
        this.stepBodies();
    }
    /**
     * 指定した二つのボディの接触であるかどうかを判定する。
     * ただし、この判定はボディそのものではなく「ボディ生成時に与えた `userData`」が一致するかで行われる。
     * 詳細は下記の「複数ボディ同士の接触イベント検出」を参照のこと。
     * https://github.com/akashic-games/akashic-box2d/blob/master/getstarted.md
     * @param body1 対象のボディ
     * @param body2 対象のボディ
     * @param contact 対象のb2Contacts
     */
    isContact(body1, body2, contact) {
        const bodyA = contact.GetFixtureA().GetBody().GetUserData();
        const bodyB = contact.GetFixtureB().GetBody().GetUserData();
        if ((body1.b2Body.GetUserData() === bodyA && body2.b2Body.GetUserData() === bodyB)
            || (body1.b2Body.GetUserData() === bodyB && body2.b2Body.GetUserData() === bodyA)) {
            return true;
        }
        return false;
    }
    /**
     * 長方形を表す `b2PolygonShape` インスタンスを生成する。
     * @param width 横幅 px
     * @param height 縦幅 px
     */
    createRectShape(width, height) {
        const shape = new box2dweb.Collision.Shapes.b2PolygonShape();
        shape.SetAsBox(width / (this.scale * 2), height / (this.scale * 2));
        return shape;
    }
    /**
     * 円を表す `b2CircleShape` インスタンスを生成する。
     * @param diameter 直径 px
     */
    createCircleShape(diameter) {
        return new box2dweb.Collision.Shapes.b2CircleShape((diameter / 2) / this.scale);
    }
    /**
     * 任意の多角形を表す `b2PolygonShape` インスタンスを生成する。
     * @param vertices[] 各頂点の `b2Vec2` 配列
     */
    createPolygonShape(vertices) {
        const shape = new box2dweb.Collision.Shapes.b2PolygonShape();
        shape.SetAsArray(vertices, vertices.length);
        return shape;
    }
    /**
     * b2FixtureDefインスタンスを生成する。
     * @param fixtureOption FixtureOption
     */
    createFixtureDef(fixtureDef) {
        const def = new box2dweb.Dynamics.b2FixtureDef();
        if (fixtureDef.shape != null) {
            def.shape = fixtureDef.shape;
        }
        if (fixtureDef.density != null) {
            def.density = fixtureDef.density;
        }
        if (fixtureDef.friction != null) {
            def.friction = fixtureDef.friction;
        }
        if (fixtureDef.restitution != null) {
            def.restitution = fixtureDef.restitution;
        }
        if (fixtureDef.isSensor != null) {
            def.isSensor = fixtureDef.isSensor;
        }
        if (fixtureDef.userData != null) {
            def.userData = fixtureDef.userData;
        }
        const opt = fixtureDef.filter;
        if (opt) {
            def.filter.categoryBits = opt.categoryBits;
            def.filter.maskBits = opt.maskBits;
            if (opt.groupIndex != null) {
                def.filter.groupIndex = opt.groupIndex;
            }
        }
        return def;
    }
    /**
     * `b2BodyDef` インスタンスを生成する。
     * @param bodyDef Box2DBodyDef
     */
    createBodyDef(bodyDef) {
        const def = new box2dweb.Dynamics.b2BodyDef();
        if (bodyDef.type != null) {
            def.type = bodyDef.type;
        }
        if (bodyDef.angularDamping != null) {
            def.angularDamping = bodyDef.angularDamping;
        }
        if (bodyDef.angularVelocity != null) {
            def.angularVelocity = bodyDef.angularVelocity;
        }
        if (bodyDef.linearDamping != null) {
            def.linearDamping = bodyDef.linearDamping;
        }
        if (bodyDef.linearDamping != null) {
            def.linearDamping = bodyDef.linearDamping;
        }
        if (bodyDef.active != null) {
            def.active = bodyDef.active;
        }
        if (bodyDef.allowSleep != null) {
            def.allowSleep = bodyDef.allowSleep;
        }
        if (bodyDef.awake != null) {
            def.awake = bodyDef.awake;
        }
        if (bodyDef.bullet != null) {
            def.bullet = bodyDef.bullet;
        }
        if (bodyDef.fixedRotation != null) {
            def.fixedRotation = bodyDef.fixedRotation;
        }
        if (bodyDef.userData != null) {
            def.userData = bodyDef.userData;
        }
        return def;
    }
    /**
     * ラジアンを度に変換する。
     * @param radian 対象のラジアン
     */
    degree(radian) {
        return radian * 180 / Math.PI;
    }
    /**
     * 度をラジアンに変換する。
     * @param degree 対象の度
     */
    radian(degree) {
        return degree * Math.PI / 180;
    }
    /**
     * この物理エンジン世界のビクセルスケールに変換した `b2Vec2` インスタンスを生成する。
     * @param x x方向のピクセル値
     * @param y y方向のピクセル値
     */
    vec2(x, y) {
        return new box2dweb.Common.Math.b2Vec2(x / this.scale, y / this.scale);
    }
    stepBodies() {
        for (let i = 0; i < this.bodies.length; i++) {
            const b2Body = this.bodies[i].b2Body;
            const entity = this.bodies[i].entity;
            if (entity.destroyed()) {
                continue;
            }
            const pos = b2Body.GetPosition();
            entity.anchorX = 0.5;
            entity.anchorY = 0.5;
            entity.x = pos.x * this.scale;
            entity.y = pos.y * this.scale;
            entity.angle = this.degree(b2Body.GetAngle());
            entity.modified();
        }
    }
}
exports.Box2D = Box2D;
